# -*- coding: utf-8 -*-
"""SA Capstone Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R9yLZrlbGGvgsTKTw2sZpyTtMARfUcKy

# **Step 1: Setting Up Your Environment**
"""

! pip install pathway bokeh pandas numpy matplotlib

"""# **Step 2: Importing Libraries & Dataset**"""

import pandas as pd
import numpy as np
import pathway as pw
import bokeh.plotting
import matplotlib.pyplot as plt

df = pd.read_csv("/content/dataset.csv")
df['datetime'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'], dayfirst=True)

"""# **Step 3: Preprocessing the Data**"""

# Preprocess the dataset
df = df.sort_values(['SystemCodeNumber', 'datetime'])

# Encode vehicle type for demand function (optional based on your needs)
vehicle_weights = {'car': 1.0, 'bike': 0.7, 'truck': 1.3, 'cycle': 0.5}
df['vehicle_weight'] = df['VehicleType'].map(vehicle_weights)

"""# **Step 4: Developing Model 1 — Baseline Linear Pricing**"""

df['price_baseline'] = 10.0  # Initialize with a float value
alpha = 2  # Linear coefficient for price adjustment
prev_price = {}

for idx, row in df.iterrows():
    lot = row['SystemCodeNumber']
    occ = row['Occupancy']
    cap = row['Capacity']

    prev = prev_price.get(lot, 10.0) # Initialize with a float value
    new_price = prev + alpha * (occ / cap)

    df.at[idx, 'price_baseline'] = new_price
    prev_price[lot] = new_price

"""# **Step 5: Developing Model 2 — Demand-Based Pricing**"""

# Demand function coefficients (you can adjust them based on experimentation)
a1, a2, a3, a4, a5 = 1.0, 0.5, 0.3, 1.0, 1.2
lambda_param = 0.3
base_price = 10

df['price_demand'] = 10.0 # Initialize with a float value

for idx, row in df.iterrows():
    occ_rate = row['Occupancy'] / row['Capacity']
    demand = (a1 * occ_rate + a2 * row['QueueLength'] - a3 * row['TrafficConditionEncoded'] +
              a4 * row['IsSpecialDay'] + a5 * row['vehicle_weight'])

    demand_norm = np.tanh(demand)  # Normalize demand to [-1,1]
    price = base_price * (1 + lambda_param * demand_norm)
    price = np.clip(price, 5, 20)

    df.at[idx, 'price_demand'] = price

# Encode TrafficConditionNearby
traffic_mapping = {'low': 0, 'average': 1, 'high': 2} # Example mapping
df['TrafficConditionEncoded'] = df['TrafficConditionNearby'].map(traffic_mapping)

"""# **Step 6: Developing Model 3 — Competitive Pricing**"""

import pandas as pd
import numpy as np
from math import radians, cos, sin, sqrt, atan2
from sklearn.neighbors import BallTree

# Convert lat/lon to radians for haversine
df['lat_rad'] = np.radians(df['Latitude'])
df['lon_rad'] = np.radians(df['Longitude'])

# Create unique list of lots with coordinates
lots_df = df[['SystemCodeNumber', 'Latitude', 'Longitude', 'lat_rad', 'lon_rad']].drop_duplicates('SystemCodeNumber')

# Build spatial tree for fast neighbor lookup
coords = lots_df[['lat_rad', 'lon_rad']].values
tree = BallTree(coords, metric='haversine')

# Radius = 1km in radians
radius = 1 / 6371

# Query neighbors for each lot
indices = tree.query_radius(coords, r=radius)

# Build mapping: {lot_id: [neighbor_lots]}
neighbor_map = {}
for i, lot_id in enumerate(lots_df['SystemCodeNumber'].values):
    neighbor_ids = lots_df.iloc[indices[i]]['SystemCodeNumber'].values
    neighbor_ids = neighbor_ids[neighbor_ids != lot_id]  # remove self
    neighbor_map[lot_id] = neighbor_ids

# Prepare for fast lookup
df['price_competitive'] = df['price_demand']  # fallback default

# Optimize by processing each timestamp group at once
for time, time_group in df.groupby('datetime'):
    time_prices = time_group.set_index('SystemCodeNumber')['price_demand'].to_dict()
    time_occ = time_group.set_index('SystemCodeNumber')['Occupancy'].to_dict()
    time_cap = time_group.set_index('SystemCodeNumber')['Capacity'].to_dict()

    for lot_id in time_group['SystemCodeNumber']:
        my_price = time_prices.get(lot_id, 10)
        occ = time_occ.get(lot_id, 0)
        cap = time_cap.get(lot_id, 1)

        neighbors = neighbor_map.get(lot_id, [])
        neighbor_prices = [time_prices[nid] for nid in neighbors if nid in time_prices]

        if neighbor_prices:
            avg_comp_price = np.mean(neighbor_prices)
            if occ >= cap:
                final_price = min(my_price, avg_comp_price)
            elif avg_comp_price > my_price:
                final_price = min(my_price + 1.5, 20)
            else:
                final_price = my_price
        else:
            final_price = my_price

        df.loc[(df['SystemCodeNumber'] == lot_id) & (df['datetime'] == time), 'price_competitive'] = final_price

"""# **Step 7: Visualization Using Bokeh**"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource

output_notebook()

lot_sample = df[df['SystemCodeNumber'] == 'BHMBCCMKT01'] # Using a sample SystemCodeNumber
source = ColumnDataSource(lot_sample)

p = figure(x_axis_type="datetime", title="Price Over Time for BHMBCCMKT01", height=300)
p.line('datetime', 'price_baseline', source=source, legend_label="Baseline", color="blue")
p.line('datetime', 'price_demand', source=source, legend_label="Demand-Based", color="green")
p.line('datetime', 'price_competitive', source=source, legend_label="Competitive", color="red")
p.legend.location = "top_left"
p.xaxis.axis_label = "Time"
p.yaxis.axis_label = "Price ($)"

show(p)

"""# **Step 8: Pathway Integration for Real-Time Simulation**"""

import pathway as pw
import numpy as np

# Define the schema for the input data
class InputSchema(pw.Schema):
    SystemCodeNumber: str
    LastUpdatedDate: str
    LastUpdatedTime: str
    Latitude: float
    Longitude: float
    Occupancy: int
    Capacity: int
    VehicleType: str
    TrafficConditionNearby: str
    QueueLength: int
    IsSpecialDay: int
    ID: int # Assuming ID is also in the input if needed

# Define the calculate_demand function as a UDF
@pw.udf
def calculate_demand(
    system_code_number: str,
    last_updated_date: str,
    last_updated_time: str,
    latitude: float,
    longitude: float,
    occupancy: int,
    capacity: int,
    vehicle_type: str,
    traffic_condition_nearby: str,
    queue_length: int,
    is_special_day: int,
    id: int
) -> float:
    # Need to handle the categorical 'TrafficConditionNearby'
    traffic_mapping = {'low': 0, 'average': 1, 'high': 2}
    traffic_encoded = traffic_mapping.get(traffic_condition_nearby, 0)

    vehicle_weights = {'car': 1.0, 'bike': 0.7, 'truck': 1.3, 'cycle': 0.5}
    vehicle_weight = vehicle_weights.get(vehicle_type, 1.0)

    occ_rate = occupancy / capacity
    a1, a2, a3, a4, a5 = 1.0, 0.5, 0.3, 1.0, 1.2

    demand = (a1 * occ_rate + a2 * queue_length - a3 * traffic_encoded +
              a4 * is_special_day + a5 * vehicle_weight)
    return float(demand)

# Define a UDF for calculating the price from demand
@pw.udf
def calculate_price(demand: float) -> float:
    lambda_param = 0.3
    base_price = 10.0
    demand_norm = np.tanh(demand)
    price = base_price * (1.0 + lambda_param * demand_norm)
    # Apply clipping within the UDF
    return float(np.clip(price, 5.0, 20.0))


# Build the Pathway pipeline
input_stream = pw.io.csv.read("/content/dataset.csv", schema=InputSchema, autocommit_duration_ms=50)

# Add datetime column
input_stream = input_stream.with_columns(
    datetime=pw.this.LastUpdatedDate + ' ' + pw.this.LastUpdatedTime
)

# Calculate demand using the calculate_demand UDF
demand_stream = input_stream.with_columns(
    demand=calculate_demand(
        pw.this.SystemCodeNumber,
        pw.this.LastUpdatedDate,
        pw.this.LastUpdatedTime,
        pw.this.Latitude,
        pw.this.Longitude,
        pw.this.Occupancy,
        pw.this.Capacity,
        pw.this.VehicleType,
        pw.this.TrafficConditionNearby,
        pw.this.QueueLength,
        pw.this.IsSpecialDay,
        pw.this.ID
    )
)

# Calculate price based on demand using the calculate_price UDF
final_pricing_stream = demand_stream.with_columns(
    final_price = calculate_price(pw.this.demand)
)

# Select the relevant columns for output
output_stream = final_pricing_stream.select(
    lot_id = pw.this.SystemCodeNumber,
    timestamp = pw.this.datetime,
    final_price = pw.this.final_price
)

# Let's uncomment pw.run() for the user to execute the pipeline
pw.run()





